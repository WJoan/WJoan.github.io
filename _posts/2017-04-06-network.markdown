---
layout:     post
title:      "网络知识"
subtitle:   "计算机网络基础知识"
date:       2017-04-07 16:34:23
author:     "Joan"
tags:	["网络","基础"]
---

# 基本知识

以下两篇文章来自阮一峰的博客，它们分别自底向上、自顶向下的介绍了计算机网络的构成。是非常好的入门文章，也可以帮助学习过网络知识的同学梳理清晰计算机网络的整体脉络。

[-> 互联网协议入门(1)](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)

[-> 互联网协议入门(2)](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)


# 各层协议

## 总结

TCP/IP协议族分为四部分：应用层、传输层、网络层、网络接口层（数据链路层+物理层）。
OSI有七层，分别为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

|OSI中的层|功能|TCP/IP协议族|
|:--------|:---|:-----------|
|应用层|文件传输，电子邮件，文件服务，虚拟终端|TFTP，`HTTP`，SNMP，`FTP`，SMTP，`DNS`，Telnet 等等|
|表示层|数据格式化，代码转换，数据加密|没有协议|
|会话层|解除或建立与别的接点的联系|没有协议|
|传输层|提供端对端的接口|`TCP`，`UDP`|
|网络层|为数据包选择路由|`IP`，`ARP`，`ICMP`，OSPF，EIGRP，IGMP|
|数据链路层|传输有地址的帧以及错误检测功能|SLIP，CSLIP，PPP，MTU|
|物理层|以二进制数据形式在物理媒体上传输数据|ISO2110，IEEE802，`IEEE802.2`|

## 网络层

网络层包括：

* IP(Internet Protocol）协议
* ICMP(Internet Control Message Protocol)控制报文协议
* ARP(Address Resolution Protocol）地址转换协议
* RARP(Reverse ARP)反向地址转换协议。

IP是网络层的核心，通过路由选择将下一条IP封装后交给接口层。IP数据报是`无连接服务`。
ICMP是网络层的补充，可以回送报文。用来检测网络是否通畅。Ping命令就是发送ICMP的echo包，通过回送的echo relay进行网络测试。

## 传输层

传输层协议主要包括：

- TCP(Transmission Control Protocol）传输控制协议
- UDP(User Datagram protocol）用户数据报协议

**TCP与UDP的区别**

|TCP|UDP|
|---|---|
|TCP是`面向连接`的通信协议，只能用于`端到端`的通讯，更加`安全`|UDP是面向`无连接`的通讯协议，可以实现`广播`发送，容易被欺骗、不安全|
|TCP提供的是一种`可靠`的数据流服务，采用`确认重传`来实现传输的可靠性，采用`滑动窗口`来进行流量控制|UDP属于`不可靠`的传输，可能会出现`丢包`现象|
|TCP数据包中包括序号和确认，所以未按照顺序收到的包可以被`排序`，而损坏的包可以被重传|UDP不管数据包的顺序、错误或重发|
|面向连接的服务（例如Telnet、FTP、rlogin、X Windows和SMTP）需要`高度的可靠性`，所以它们使用了TCP。DNS在某些情况下使用TCP（发送和接收域名数据库）|UDP主要用于那些面向`查询-应答`这样的`信息量交换较少`的服务。使用UDP的服务包括NTP（网络时间协议）和DNS（DNS也使用TCP）|

## 应用层

应用层协议主要包括如下几个：

- FTP(File Transfer Protocol）是文件传输协议，一般上传下载用FTP服务，数据端口是20H，控制端口是21H。
- Telnet服务是用户远程登录服务，使用23H端口，使用明码传送，保密性差、简单方便。
- DNS(Domain Name Service）是域名解析服务，提供域名到IP地址之间的转换，使用端口53。
- SMTP(Simple Mail Transfer Protocol）是简单邮件传输协议，用来控制信件的发送、中转，使用端口25。
- NFS（Network File System）是网络文件系统，用于网络中不同主机间的文件共享。
- HTTP(Hypertext Transfer Protocol）是超文本传输协议，用于实现互联网中的WWW服务，使用端口80。

# 当你在浏览器输入回车后发生了什么

这是一道非常经典的面试题。

https://github.com/skyline75489/what-happens-when-zh_CN

# DNS

# TCP

## TCP三次握手和四次挥手

无论是三次握手还是四次挥手，双方都进行了两个来回的“沟通”，即SYN/FIN、ACK、SYN/FIN、ACK。只是在三次握手中，server的发送的`SYN`以及`ACK`一起发送了。其中发送`SYN`或者`FIN`的时候需要跟随一个`seq`（序列号），返回`ACK`的时候需要附带一个`ack`=seq+1(即接收方期望接收的下一个序列号)。[详细过程>>](http://www.2cto.com/net/201310/251896.html)

<a href="#">
    <img src="{{ site.baseurl }}/img/network-tcp-3.png" alt="network-tcp-3">
</a>


<a href="#">
    <img src="{{ site.baseurl }}/img/network-tcp-4.png" alt="network-tcp-4">
</a>

### 客户端TCP状态迁移：
CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED

### 服务器TCP状态迁移：
CLOSED->LISTEN->SYN收到->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED

### Q1：建立连接协议是三次握手，而关闭连接却是四次握手呢？
这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

### Q2：TCP四次挥手中的2MSL是什么？
第四次握手的ACK包后就进入了`TIME_WAIT`状态，必须在此状态上停留两倍的`MSL`时间（Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”），等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在`TIME_WAIT`状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。

### Q3：服务器端的CLOSE_WAIT状态是指什么？
在收到客户端的FIN之后，服务器又没有发送FIN之前，服务器端会处于`CLOSE_WAIT`状态。主要是因为在服务器发送FIN之前，也就是停止服务器向客户端发送数据之前，要把没有发送完的数据发送完毕。

## 流量控制与拥塞控制

# HTTP

[HTTP简单介绍](http://www.ruanyifeng.com/blog/2016/08/http.html)

- `无连接`：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- `媒体独立的`：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
- `无状态`：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式
![HTTP请求](http://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png)

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
![HTTP响应](http://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg)

## 请求方法

|序号	|方法	|描述   |
|:------|:------|:------|
|1	|GET	|请求指定的页面信息，并返回实体主体。|
|2	|HEAD	|类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。|
|3	|POST	|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。|
|4	|PUT	|从客户端向服务器传送的数据取代指定的文档的内容。|
|5	|DELETE	|请求服务器删除指定的页面。|
|6	|CONNECT	|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。|
|7	|OPTIONS	|允许客户端查看服务器的性能。|
|8	|TRACE	|回显服务器收到的请求，主要用于测试或诊断。|

### GET与POST的区别

| -	|GET	|POST|
|:--|:------|:---|
|后退按钮/刷新	|无害	|数据会被重新提交（浏览器应该告知用户数据会被重新提交）。|
|书签	|可收藏为书签	|不可收藏为书签|
|缓存	|能被缓存	|不能缓存|
|编码类型	|application/x-www-form-urlencoded	|application/x-www-form-urlencoded 或 multipart/form-data。<br>为二进制数据使用多重编码。|
|历史	|参数保留在浏览器历史中。	|参数不会保存在浏览器历史中。|
|数据长度的限制	|当发送数据时，GET 方法向 URL 添加数据。<br>通常URL 的长度是受限制的，具体限制要看浏览器和服务器|无限制。|
|数据类型的限制	|只允许 ASCII 字符。	|没有限制。也允许二进制数据。|
|安全性|与 POST 相比，GET 的安全性较差。<br>因为所发送的数据是 URL 的一部分。<br>在发送密码或其他敏感信息时绝不要使用 GET ！|POST 比 GET 更安全。<br>因为参数不会被保存在浏览器历史或 web 服务器日志中。|
|可见性	|数据在 URL 中对所有人都是可见的。	|数据不会显示在 URL 中。|

## 状态码

### 状态码分类

|分类	|分类描述|
|:------|:-------|
|1**	|信息，服务器收到请求，需要请求者继续执行操作|
|2**	|成功，操作被成功接收并处理|
|3**	|重定向，需要进一步的操作以完成请求|
|4**	|客户端错误，请求包含语法错误或无法完成请求|
|5**	|服务器错误，服务器在处理请求的过程中发生了错误|

### 常见的状态码

- 200	OK	请求成功。一般用于GET与POST请求
- 301	Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
- 302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
- 304	Not Modified	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
- 401	Unauthorized	请求要求用户的身份认证
- 403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求
- 404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
- 500	Internal Server Error	服务器内部错误，无法完成请求
- 504	Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求

# HTTPS



